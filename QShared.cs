/*
 * Copyright (C) 1997-2001 Id Software, Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA.
 *
 * =======================================================================
 *
 * This is the main header file shared between client, renderer, server
 * and the game. Do NOT edit this file unless you know what you're
 * doing. Changes here may break the client <-> renderer <-> server
 * <-> game API, leading to problems with mods!
 *
 * =======================================================================
 */

using System.Numerics;
using System.Text;
using Silk.NET.Maths;

namespace Quake2 {

    /*
    * ==========================================================
    *
    * CVARS (console variables)
    *
    * ==========================================================
    */

    /* nothing outside the Cvar_*() functions should modify these fields! */
    class cvar_t
    {
        public const int CVAR_ARCHIVE = 1;     /* set to cause it to be saved to vars.rc */
        public const int CVAR_USERINFO = 2;    /* added to userinfo  when changed */
        public const int CVAR_SERVERINFO = 4;  /* added to serverinfo when changed */
        public const int CVAR_NOSET = 8;       /* don't allow change from console at all, */
                                               /* but can be set from the command line */
        public const int CVAR_LATCH = 16;      /* save changes until server restart */

        public cvar_t (string name, string value, int flags)
        {
            this.name = name;
            this.str = value;
            this.default_string = value;
            this.flags = flags;
            this.modified = true;
            this.latched_string = null;
        }

        public readonly string name;
        public string str;
        public string? latched_string; /* for CVAR_LATCH vars */
        public int flags;
        public bool modified; /* set each time the cvar is changed */

        /* Added by YQ2. Must be at the end to preserve ABI. */
        public string default_string;

        public bool Bool {
            get {
                try {
                    var p = Convert.ToDouble(str, QShared.provider);
                    return (p != 0.0);
                } catch (Exception) {
                    return false;
                }
            }
        }

        public int Int {
            get {
                try {
                    var p = Convert.ToDouble(str, QShared.provider);
                    return (int)p;
                } catch (Exception e) {
                    Console.WriteLine($"Cannot parse \"{str}\" {e.Message}");
                    return 0;
                }
            }
        }

        public double Double {
            get {
                try {
                    return Convert.ToDouble(str, QShared.provider);
                } catch (Exception e) {
                    Console.WriteLine($"Cannot parse \"{str}\" {e.Message}");
                    return 0;
                }
            }
        }

        public float Float {
            get {
                try {
                    return (float)Convert.ToDouble(str, QShared.provider);
                } catch (Exception e) {
                    Console.WriteLine($"Cannot parse \"{str}\" {e.Message}");
                    return 0;
                }
            }
        }

    }

    internal class QShared {

        /* angle indexes */
        public const int PITCH = 0;                     /* up / down */
        public const int YAW = 1;                       /* left / right */
        public const int ROLL = 2;                      /* fall over */

        /* per-level limits */
        public const int MAX_CLIENTS = 256;             /* absolute limit */
        public const int MAX_EDICTS = 1024;             /* must change protocol to increase more */
        public const int MAX_LIGHTSTYLES = 256;
        public const int MAX_MODELS = 256;              /* these are sent over the net as bytes */
        public const int MAX_SOUNDS = 256;              /* so they cannot be blindly increased */
        public const int MAX_IMAGES = 256;
        public const int MAX_ITEMS = 256;
        public const int MAX_GENERAL = (MAX_CLIENTS * 2);       /* general config strings */

        /* game print flags */
        public const int PRINT_LOW = 0;                 /* pickup messages */
        public const int PRINT_MEDIUM = 1;              /* death messages */
        public const int PRINT_HIGH = 2;                /* critical messages */
        public const int PRINT_CHAT = 3;                /* chat messages */

        public const int ERR_FATAL = 0;                 /* exit the entire game with a popup window */
        public const int ERR_DROP = 1;                  /* print to console and disconnect from game */
        public const int ERR_DISCONNECT = 2;            /* don't kill server */

        public const int PRINT_ALL = 0;
        public const int PRINT_DEVELOPER = 1;           /* only print when "developer 1" */
        public const int PRINT_ALERT = 2;

        /* destination class for gi.multicast() */
        internal enum multicast_t
        {
            MULTICAST_ALL,
            MULTICAST_PHS,
            MULTICAST_PVS,
            MULTICAST_ALL_R,
            MULTICAST_PHS_R,
            MULTICAST_PVS_R
        }

        /* content masks */
        internal const int MASK_ALL = -1;
        internal const int MASK_SOLID = QCommon.CONTENTS_SOLID | QCommon.CONTENTS_WINDOW;
        internal const int MASK_PLAYERSOLID =
            (QCommon.CONTENTS_SOLID | QCommon.CONTENTS_PLAYERCLIP |
            QCommon.CONTENTS_WINDOW | QCommon.CONTENTS_MONSTER);
        internal const int MASK_DEADSOLID = (QCommon.CONTENTS_SOLID | QCommon.CONTENTS_PLAYERCLIP | QCommon.CONTENTS_WINDOW);
        internal const int MASK_MONSTERSOLID =
            (QCommon.CONTENTS_SOLID | QCommon.CONTENTS_MONSTERCLIP |
            QCommon.CONTENTS_WINDOW | QCommon.CONTENTS_MONSTER);
        internal const int MASK_WATER = (QCommon.CONTENTS_WATER | QCommon.CONTENTS_LAVA | QCommon.CONTENTS_SLIME);
        internal const int MASK_OPAQUE = (QCommon.CONTENTS_SOLID | QCommon.CONTENTS_SLIME | QCommon.CONTENTS_LAVA);
        internal const int MASK_SHOT =
            (QCommon.CONTENTS_SOLID | QCommon.CONTENTS_MONSTER | QCommon.CONTENTS_WINDOW |
            QCommon.CONTENTS_DEADMONSTER);
        internal const int MASK_CURRENT =
            (QCommon.CONTENTS_CURRENT_0 | QCommon.CONTENTS_CURRENT_90 |
            QCommon.CONTENTS_CURRENT_180 | QCommon.CONTENTS_CURRENT_270 |
            QCommon.CONTENTS_CURRENT_UP |
            QCommon.CONTENTS_CURRENT_DOWN);

        /* plane_t structure */
        public class cplane_t
        {
            public Vector3 normal;
            public float dist;
            public byte type; /* for fast side tests */
            public byte signbits; /* signx + (signy<<1) + (signz<<2) */
            // byte pad[2];
        }

        public class cmodel_t
        {
            public Vector3 mins, maxs;
            public Vector3 origin; /* for sounds or lights */
            public int headnode;
        }

        public struct csurface_t
        {
            public string name;
            public int flags; /* SURF_* */
            public int value; /* unused */
        }

        public class mapsurface_t  /* used internally due to name len probs */
        {
            public csurface_t c;
            public string rname;
        }

        /* a trace is returned when a box is swept through the world */
        public struct trace_t
        {
            public bool allsolid;      /* if true, plane is not valid */
            public bool startsolid;    /* if true, the initial point was in a solid area */
            public float fraction;         /* time completed, 1.0 = didn't hit anything */
            public Vector3 endpos;          /* final position */
            public cplane_t plane;         /* surface normal at impact */
            public csurface_t? surface;    /* surface hit */
            public int contents;           /* contents on other side of surface hit */
            public edict_s? ent;    /* not set by CM_*() functions */
        } ;

        /* pmove_state_t is the information necessary for client side movement */
        /* prediction */
        public enum pmtype_t
        {
            /* can accelerate and turn */
            PM_NORMAL,
            PM_SPECTATOR,
            /* no acceleration or turning */
            PM_DEAD,
            PM_GIB, /* different bounding box */
            PM_FREEZE
        } ;

        /* pmove->pm_flags */
        public const byte PMF_DUCKED = 1;
        public const byte PMF_JUMP_HELD = 2;
        public const byte PMF_ON_GROUND = 4;
        public const byte PMF_TIME_WATERJUMP = 8;    /* pm_time is waterjump */
        public const byte PMF_TIME_LAND = 16;        /* pm_time is time before rejump */
        public const byte PMF_TIME_TELEPORT = 32;    /* pm_time is non-moving time */
        public const byte PMF_NO_PREDICTION = 64;    /* temporarily disables prediction (used for grappling hook) */

        /* this structure needs to be communicated bit-accurate/
        * from the server to the client to guarantee that
        * prediction stays in sync, so no floats are used.
        * if any part of the game code modifies this struct, it
        * will result in a prediction error of some degree. */
        public struct pmove_state_t
        {
            public pmtype_t pm_type;

            public short[] origin;            /* 12.3 */
            public short[] velocity;          /* 12.3 */
            public byte pm_flags;              /* ducked, jump_held, etc */
            public byte pm_time;               /* each unit = 8 ms */
            public short gravity;
            public short[] delta_angles;      /* add to command angles to get view direction
                                        * changed by spawns, rotating objects, and teleporters */
        }

        /* button bits */
        public const byte BUTTON_ATTACK = 1;
        public const byte BUTTON_USE = 2;
        public const byte BUTTON_ANY = 128; /* any key whatsoever */

        /* usercmd_t is sent to the server each client frame */
        public struct usercmd_t
        {
            public byte msec;
            public byte buttons;
            public short[] angles;
            public short forwardmove, sidemove, upmove;
            public byte impulse;           /* remove? */
            public byte lightlevel;        /* light level the player is standing on */

            public void Clear()
            {
                msec = 0;
                buttons = 0;
                angles = new short[3]{ 0, 0, 0};
                forwardmove = 0;
                sidemove = 0;
                upmove = 0;
                impulse = 0;
                lightlevel = 0;
            }
        }

        public const int MAXTOUCH = 32;

        internal delegate trace_t trace_delegate(in Vector3 start, in Vector3 mins, in Vector3 maxs, in Vector3 end);

        internal struct pmove_t
        {
            /* state (in / out) */
            public pmove_state_t s;

            /* command (in) */
            public usercmd_t cmd;
            public  bool snapinitial;           /* if s has been changed outside pmove */

            /* results (out) */
            public int numtouch;
            public  edict_s?[] touchents; // [MAXTOUCH];

            public Vector3 viewangles;              /* clamped */
            public float viewheight;

            public Vector3 mins, maxs;              /* bounding box size */

            public edict_s? groundentity;
            public int watertype;
            public int waterlevel;

            /* callbacks to test the world */
            public trace_delegate? trace;
            // int (*pointcontents)(vec3_t point);
        }

        /* entity_state_t->effects
        * Effects are things handled on the client side (lights, particles,
        * frame animations)  that happen constantly on the given entity.
        * An entity that has effects will be sent to the client even if
        * it has a zero index model. */
        public const int EF_ROTATE = 0x00000001;                /* rotate (bonus items) */
        public const int EF_GIB = 0x00000002;                   /* leave a trail */
        public const int EF_BLASTER = 0x00000008;               /* redlight + trail */
        public const int EF_ROCKET = 0x00000010;                /* redlight + trail */
        public const int EF_GRENADE = 0x00000020;
        public const int EF_HYPERBLASTER = 0x00000040;
        public const int EF_BFG = 0x00000080;
        public const int EF_COLOR_SHELL = 0x00000100;
        public const int EF_POWERSCREEN = 0x00000200;
        public const int EF_ANIM01 = 0x00000400;                /* automatically cycle between frames 0 and 1 at 2 hz */
        public const int EF_ANIM23 = 0x00000800;                /* automatically cycle between frames 2 and 3 at 2 hz */
        public const int EF_ANIM_ALL = 0x00001000;              /* automatically cycle through all frames at 2hz */
        public const int EF_ANIM_ALLFAST = 0x00002000;          /* automatically cycle through all frames at 10hz */
        public const int EF_FLIES = 0x00004000;
        public const int EF_QUAD = 0x00008000;
        public const int EF_PENT = 0x00010000;
        public const int EF_TELEPORTER = 0x00020000;            /* particle fountain */
        public const int EF_FLAG1 = 0x00040000;
        public const int EF_FLAG2 = 0x00080000;
        public const int EF_IONRIPPER = 0x00100000;
        public const int EF_GREENGIB = 0x00200000;
        public const int EF_BLUEHYPERBLASTER = 0x00400000;
        public const int EF_SPINNINGLIGHTS = 0x00800000;
        public const int EF_PLASMA = 0x01000000;
        public const int EF_TRAP = 0x02000000;
        public const int EF_TRACKER = 0x04000000;
        public const int EF_DOUBLE = 0x08000000;
        public const int EF_SPHERETRANS = 0x10000000;
        public const int EF_TAGTRAIL = 0x20000000;
        public const int EF_HALF_DAMAGE = 0x40000000;
        public const uint EF_TRACKERTRAIL = 0x80000000U;

        /* entity_state_t->renderfx flags */
        public const int RF_MINLIGHT = 1;               /* allways have some light (viewmodel) */
        public const int RF_VIEWERMODEL = 2;            /* don't draw through eyes, only mirrors */
        public const int RF_WEAPONMODEL = 4;            /* only draw through eyes */
        public const int RF_FULLBRIGHT = 8;             /* allways draw full intensity */
        public const int RF_DEPTHHACK = 16;             /* for view weapon Z crunching */
        public const int RF_TRANSLUCENT = 32;
        public const int RF_FRAMELERP = 64;
        public const int RF_BEAM = 128;
        public const int RF_CUSTOMSKIN = 256;           /* skin is an index in image_precache */
        public const int RF_GLOW = 512;                 /* pulse lighting for bonus items */
        public const int RF_SHELL_RED = 1024;
        public const int RF_SHELL_GREEN = 2048;
        public const int RF_SHELL_BLUE = 4096;
        public const int RF_NOSHADOW = 8192;        /* don't draw a shadow */
        public const int RF_IR_VISIBLE = 0x00008000;            /* 32768 */
        public const int RF_SHELL_DOUBLE = 0x00010000;          /* 65536 */
        public const int RF_SHELL_HALF_DAM = 0x00020000;
        public const int RF_USE_DISGUISE = 0x00040000;

        /* player_state_t->refdef flags */
        public const int RDF_UNDERWATER = 1;            /* warp the screen as apropriate */
        public const int RDF_NOWORLDMODEL = 2;          /* used for player configuration screen */
        public const int RDF_IRGOGGLES = 4;
        public const int RDF_UVGOGGLES = 8;

        /* muzzle flashes / player effects */
        public const int MZ_BLASTER = 0;
        public const int MZ_MACHINEGUN = 1;
        public const int MZ_SHOTGUN = 2;
        public const int MZ_CHAINGUN1 = 3;
        public const int MZ_CHAINGUN2 = 4;
        public const int MZ_CHAINGUN3 = 5;
        public const int MZ_RAILGUN = 6;
        public const int MZ_ROCKET = 7;
        public const int MZ_GRENADE = 8;
        public const int MZ_LOGIN = 9;
        public const int MZ_LOGOUT = 10;
        public const int MZ_RESPAWN = 11;
        public const int MZ_BFG = 12;
        public const int MZ_SSHOTGUN = 13;
        public const int MZ_HYPERBLASTER = 14;
        public const int MZ_ITEMRESPAWN = 15;
        public const int MZ_IONRIPPER = 16;
        public const int MZ_BLUEHYPERBLASTER = 17;
        public const int MZ_PHALANX = 18;
        public const int MZ_SILENCED = 128;             /* bit flag ORed with one of the above numbers */
        public const int MZ_ETF_RIFLE = 30;
        public const int MZ_UNUSED = 31;
        public const int MZ_SHOTGUN2 = 32;
        public const int MZ_HEATBEAM = 33;
        public const int MZ_BLASTER2 = 34;
        public const int MZ_TRACKER = 35;
        public const int MZ_NUKE1 = 36;
        public const int MZ_NUKE2 = 37;
        public const int MZ_NUKE4 = 38;
        public const int MZ_NUKE8 = 39;

        /* monster muzzle flashes */
        public const int MZ2_TANK_BLASTER_1 = 1;
        public const int MZ2_TANK_BLASTER_2 = 2;
        public const int MZ2_TANK_BLASTER_3 = 3;
        public const int MZ2_TANK_MACHINEGUN_1 = 4;
        public const int MZ2_TANK_MACHINEGUN_2 = 5;
        public const int MZ2_TANK_MACHINEGUN_3 = 6;
        public const int MZ2_TANK_MACHINEGUN_4 = 7;
        public const int MZ2_TANK_MACHINEGUN_5 = 8;
        public const int MZ2_TANK_MACHINEGUN_6 = 9;
        public const int MZ2_TANK_MACHINEGUN_7 = 10;
        public const int MZ2_TANK_MACHINEGUN_8 = 11;
        public const int MZ2_TANK_MACHINEGUN_9 = 12;
        public const int MZ2_TANK_MACHINEGUN_10 = 13;
        public const int MZ2_TANK_MACHINEGUN_11 = 14;
        public const int MZ2_TANK_MACHINEGUN_12 = 15;
        public const int MZ2_TANK_MACHINEGUN_13 = 16;
        public const int MZ2_TANK_MACHINEGUN_14 = 17;
        public const int MZ2_TANK_MACHINEGUN_15 = 18;
        public const int MZ2_TANK_MACHINEGUN_16 = 19;
        public const int MZ2_TANK_MACHINEGUN_17 = 20;
        public const int MZ2_TANK_MACHINEGUN_18 = 21;
        public const int MZ2_TANK_MACHINEGUN_19 = 22;
        public const int MZ2_TANK_ROCKET_1 = 23;
        public const int MZ2_TANK_ROCKET_2 = 24;
        public const int MZ2_TANK_ROCKET_3 = 25;

        public const int MZ2_INFANTRY_MACHINEGUN_1 = 26;
        public const int MZ2_INFANTRY_MACHINEGUN_2 = 27;
        public const int MZ2_INFANTRY_MACHINEGUN_3 = 28;
        public const int MZ2_INFANTRY_MACHINEGUN_4 = 29;
        public const int MZ2_INFANTRY_MACHINEGUN_5 = 30;
        public const int MZ2_INFANTRY_MACHINEGUN_6 = 31;
        public const int MZ2_INFANTRY_MACHINEGUN_7 = 32;
        public const int MZ2_INFANTRY_MACHINEGUN_8 = 33;
        public const int MZ2_INFANTRY_MACHINEGUN_9 = 34;
        public const int MZ2_INFANTRY_MACHINEGUN_10 = 35;
        public const int MZ2_INFANTRY_MACHINEGUN_11 = 36;
        public const int MZ2_INFANTRY_MACHINEGUN_12 = 37;
        public const int MZ2_INFANTRY_MACHINEGUN_13 = 38;

        public const int MZ2_SOLDIER_BLASTER_1 = 39;
        public const int MZ2_SOLDIER_BLASTER_2 = 40;
        public const int MZ2_SOLDIER_SHOTGUN_1 = 41;
        public const int MZ2_SOLDIER_SHOTGUN_2 = 42;
        public const int MZ2_SOLDIER_MACHINEGUN_1 = 43;
        public const int MZ2_SOLDIER_MACHINEGUN_2 = 44;

        public const int MZ2_GUNNER_MACHINEGUN_1 = 45;
        public const int MZ2_GUNNER_MACHINEGUN_2 = 46;
        public const int MZ2_GUNNER_MACHINEGUN_3 = 47;
        public const int MZ2_GUNNER_MACHINEGUN_4 = 48;
        public const int MZ2_GUNNER_MACHINEGUN_5 = 49;
        public const int MZ2_GUNNER_MACHINEGUN_6 = 50;
        public const int MZ2_GUNNER_MACHINEGUN_7 = 51;
        public const int MZ2_GUNNER_MACHINEGUN_8 = 52;
        public const int MZ2_GUNNER_GRENADE_1 = 53;
        public const int MZ2_GUNNER_GRENADE_2 = 54;
        public const int MZ2_GUNNER_GRENADE_3 = 55;
        public const int MZ2_GUNNER_GRENADE_4 = 56;

        public const int MZ2_CHICK_ROCKET_1 = 57;

        public const int MZ2_FLYER_BLASTER_1 = 58;
        public const int MZ2_FLYER_BLASTER_2 = 59;

        public const int MZ2_MEDIC_BLASTER_1 = 60;

        public const int MZ2_GLADIATOR_RAILGUN_1 = 61;

        public const int MZ2_HOVER_BLASTER_1 = 62;

        public const int MZ2_ACTOR_MACHINEGUN_1 = 63;

        public const int MZ2_SUPERTANK_MACHINEGUN_1 = 64;
        public const int MZ2_SUPERTANK_MACHINEGUN_2 = 65;
        public const int MZ2_SUPERTANK_MACHINEGUN_3 = 66;
        public const int MZ2_SUPERTANK_MACHINEGUN_4 = 67;
        public const int MZ2_SUPERTANK_MACHINEGUN_5 = 68;
        public const int MZ2_SUPERTANK_MACHINEGUN_6 = 69;
        public const int MZ2_SUPERTANK_ROCKET_1 = 70;
        public const int MZ2_SUPERTANK_ROCKET_2 = 71;
        public const int MZ2_SUPERTANK_ROCKET_3 = 72;

        public const int MZ2_BOSS2_MACHINEGUN_L1 = 73;
        public const int MZ2_BOSS2_MACHINEGUN_L2 = 74;
        public const int MZ2_BOSS2_MACHINEGUN_L3 = 75;
        public const int MZ2_BOSS2_MACHINEGUN_L4 = 76;
        public const int MZ2_BOSS2_MACHINEGUN_L5 = 77;
        public const int MZ2_BOSS2_ROCKET_1 = 78;
        public const int MZ2_BOSS2_ROCKET_2 = 79;
        public const int MZ2_BOSS2_ROCKET_3 = 80;
        public const int MZ2_BOSS2_ROCKET_4 = 81;

        public const int MZ2_FLOAT_BLASTER_1 = 82;

        public const int MZ2_SOLDIER_BLASTER_3 = 83;
        public const int MZ2_SOLDIER_SHOTGUN_3 = 84;
        public const int MZ2_SOLDIER_MACHINEGUN_3 = 85;
        public const int MZ2_SOLDIER_BLASTER_4 = 86;
        public const int MZ2_SOLDIER_SHOTGUN_4 = 87;
        public const int MZ2_SOLDIER_MACHINEGUN_4 = 88;
        public const int MZ2_SOLDIER_BLASTER_5 = 89;
        public const int MZ2_SOLDIER_SHOTGUN_5 = 90;
        public const int MZ2_SOLDIER_MACHINEGUN_5 = 91;
        public const int MZ2_SOLDIER_BLASTER_6 = 92;
        public const int MZ2_SOLDIER_SHOTGUN_6 = 93;
        public const int MZ2_SOLDIER_MACHINEGUN_6 = 94;
        public const int MZ2_SOLDIER_BLASTER_7 = 95;
        public const int MZ2_SOLDIER_SHOTGUN_7 = 96;
        public const int MZ2_SOLDIER_MACHINEGUN_7 = 97;
        public const int MZ2_SOLDIER_BLASTER_8 = 98;
        public const int MZ2_SOLDIER_SHOTGUN_8 = 99;
        public const int MZ2_SOLDIER_MACHINEGUN_8 = 100;

        public const int MZ2_MAKRON_BFG = 101;
        public const int MZ2_MAKRON_BLASTER_1 = 102;
        public const int MZ2_MAKRON_BLASTER_2 = 103;
        public const int MZ2_MAKRON_BLASTER_3 = 104;
        public const int MZ2_MAKRON_BLASTER_4 = 105;
        public const int MZ2_MAKRON_BLASTER_5 = 106;
        public const int MZ2_MAKRON_BLASTER_6 = 107;
        public const int MZ2_MAKRON_BLASTER_7 = 108;
        public const int MZ2_MAKRON_BLASTER_8 = 109;
        public const int MZ2_MAKRON_BLASTER_9 = 110;
        public const int MZ2_MAKRON_BLASTER_10 = 111;
        public const int MZ2_MAKRON_BLASTER_11 = 112;
        public const int MZ2_MAKRON_BLASTER_12 = 113;
        public const int MZ2_MAKRON_BLASTER_13 = 114;
        public const int MZ2_MAKRON_BLASTER_14 = 115;
        public const int MZ2_MAKRON_BLASTER_15 = 116;
        public const int MZ2_MAKRON_BLASTER_16 = 117;
        public const int MZ2_MAKRON_BLASTER_17 = 118;
        public const int MZ2_MAKRON_RAILGUN_1 = 119;
        public const int MZ2_JORG_MACHINEGUN_L1 = 120;
        public const int MZ2_JORG_MACHINEGUN_L2 = 121;
        public const int MZ2_JORG_MACHINEGUN_L3 = 122;
        public const int MZ2_JORG_MACHINEGUN_L4 = 123;
        public const int MZ2_JORG_MACHINEGUN_L5 = 124;
        public const int MZ2_JORG_MACHINEGUN_L6 = 125;
        public const int MZ2_JORG_MACHINEGUN_R1 = 126;
        public const int MZ2_JORG_MACHINEGUN_R2 = 127;
        public const int MZ2_JORG_MACHINEGUN_R3 = 128;
        public const int MZ2_JORG_MACHINEGUN_R4 = 129;
        public const int MZ2_JORG_MACHINEGUN_R5 = 130;
        public const int MZ2_JORG_MACHINEGUN_R6 = 131;
        public const int MZ2_JORG_BFG_1 = 132;
        public const int MZ2_BOSS2_MACHINEGUN_R1 = 133;
        public const int MZ2_BOSS2_MACHINEGUN_R2 = 134;
        public const int MZ2_BOSS2_MACHINEGUN_R3 = 135;
        public const int MZ2_BOSS2_MACHINEGUN_R4 = 136;
        public const int MZ2_BOSS2_MACHINEGUN_R5 = 137;

        public const int MZ2_CARRIER_MACHINEGUN_L1 = 138;
        public const int MZ2_CARRIER_MACHINEGUN_R1 = 139;
        public const int MZ2_CARRIER_GRENADE = 140;
        public const int MZ2_TURRET_MACHINEGUN = 141;
        public const int MZ2_TURRET_ROCKET = 142;
        public const int MZ2_TURRET_BLASTER = 143;
        public const int MZ2_STALKER_BLASTER = 144;
        public const int MZ2_DAEDALUS_BLASTER = 145;
        public const int MZ2_MEDIC_BLASTER_2 = 146;
        public const int MZ2_CARRIER_RAILGUN = 147;
        public const int MZ2_WIDOW_DISRUPTOR = 148;
        public const int MZ2_WIDOW_BLASTER = 149;
        public const int MZ2_WIDOW_RAIL = 150;
        public const int MZ2_WIDOW_PLASMABEAM = 151;
        public const int MZ2_CARRIER_MACHINEGUN_L2 = 152;
        public const int MZ2_CARRIER_MACHINEGUN_R2 = 153;
        public const int MZ2_WIDOW_RAIL_LEFT = 154;
        public const int MZ2_WIDOW_RAIL_RIGHT = 155;
        public const int MZ2_WIDOW_BLASTER_SWEEP1 = 156;
        public const int MZ2_WIDOW_BLASTER_SWEEP2 = 157;
        public const int MZ2_WIDOW_BLASTER_SWEEP3 = 158;
        public const int MZ2_WIDOW_BLASTER_SWEEP4 = 159;
        public const int MZ2_WIDOW_BLASTER_SWEEP5 = 160;
        public const int MZ2_WIDOW_BLASTER_SWEEP6 = 161;
        public const int MZ2_WIDOW_BLASTER_SWEEP7 = 162;
        public const int MZ2_WIDOW_BLASTER_SWEEP8 = 163;
        public const int MZ2_WIDOW_BLASTER_SWEEP9 = 164;
        public const int MZ2_WIDOW_BLASTER_100 = 165;
        public const int MZ2_WIDOW_BLASTER_90 = 166;
        public const int MZ2_WIDOW_BLASTER_80 = 167;
        public const int MZ2_WIDOW_BLASTER_70 = 168;
        public const int MZ2_WIDOW_BLASTER_60 = 169;
        public const int MZ2_WIDOW_BLASTER_50 = 170;
        public const int MZ2_WIDOW_BLASTER_40 = 171;
        public const int MZ2_WIDOW_BLASTER_30 = 172;
        public const int MZ2_WIDOW_BLASTER_20 = 173;
        public const int MZ2_WIDOW_BLASTER_10 = 174;
        public const int MZ2_WIDOW_BLASTER_0 = 175;
        public const int MZ2_WIDOW_BLASTER_10L = 176;
        public const int MZ2_WIDOW_BLASTER_20L = 177;
        public const int MZ2_WIDOW_BLASTER_30L = 178;
        public const int MZ2_WIDOW_BLASTER_40L = 179;
        public const int MZ2_WIDOW_BLASTER_50L = 180;
        public const int MZ2_WIDOW_BLASTER_60L = 181;
        public const int MZ2_WIDOW_BLASTER_70L = 182;
        public const int MZ2_WIDOW_RUN_1 = 183;
        public const int MZ2_WIDOW_RUN_2 = 184;
        public const int MZ2_WIDOW_RUN_3 = 185;
        public const int MZ2_WIDOW_RUN_4 = 186;
        public const int MZ2_WIDOW_RUN_5 = 187;
        public const int MZ2_WIDOW_RUN_6 = 188;
        public const int MZ2_WIDOW_RUN_7 = 189;
        public const int MZ2_WIDOW_RUN_8 = 190;
        public const int MZ2_CARRIER_ROCKET_1 = 191;
        public const int MZ2_CARRIER_ROCKET_2 = 192;
        public const int MZ2_CARRIER_ROCKET_3 = 193;
        public const int MZ2_CARRIER_ROCKET_4 = 194;
        public const int MZ2_WIDOW2_BEAMER_1 = 195;
        public const int MZ2_WIDOW2_BEAMER_2 = 196;
        public const int MZ2_WIDOW2_BEAMER_3 = 197;
        public const int MZ2_WIDOW2_BEAMER_4 = 198;
        public const int MZ2_WIDOW2_BEAMER_5 = 199;
        public const int MZ2_WIDOW2_BEAM_SWEEP_1 = 200;
        public const int MZ2_WIDOW2_BEAM_SWEEP_2 = 201;
        public const int MZ2_WIDOW2_BEAM_SWEEP_3 = 202;
        public const int MZ2_WIDOW2_BEAM_SWEEP_4 = 203;
        public const int MZ2_WIDOW2_BEAM_SWEEP_5 = 204;
        public const int MZ2_WIDOW2_BEAM_SWEEP_6 = 205;
        public const int MZ2_WIDOW2_BEAM_SWEEP_7 = 206;
        public const int MZ2_WIDOW2_BEAM_SWEEP_8 = 207;
        public const int MZ2_WIDOW2_BEAM_SWEEP_9 = 208;
        public const int MZ2_WIDOW2_BEAM_SWEEP_10 = 209;
        public const int MZ2_WIDOW2_BEAM_SWEEP_11 = 210;

        /* Temp entity events are for things that happen
        * at a location seperate from any existing entity.
        * Temporary entity messages are explicitly constructed
        * and broadcast. */
        public enum temp_event_t
        {
            TE_GUNSHOT,
            TE_BLOOD,
            TE_BLASTER,
            TE_RAILTRAIL,
            TE_SHOTGUN,
            TE_EXPLOSION1,
            TE_EXPLOSION2,
            TE_ROCKET_EXPLOSION,
            TE_GRENADE_EXPLOSION,
            TE_SPARKS,
            TE_SPLASH,
            TE_BUBBLETRAIL,
            TE_SCREEN_SPARKS,
            TE_SHIELD_SPARKS,
            TE_BULLET_SPARKS,
            TE_LASER_SPARKS,
            TE_PARASITE_ATTACK,
            TE_ROCKET_EXPLOSION_WATER,
            TE_GRENADE_EXPLOSION_WATER,
            TE_MEDIC_CABLE_ATTACK,
            TE_BFG_EXPLOSION,
            TE_BFG_BIGEXPLOSION,
            TE_BOSSTPORT,           /* used as '22' in a map, so DON'T RENUMBER!!! */
            TE_BFG_LASER,
            TE_GRAPPLE_CABLE,
            TE_WELDING_SPARKS,
            TE_GREENBLOOD,
            TE_BLUEHYPERBLASTER,
            TE_PLASMA_EXPLOSION,
            TE_TUNNEL_SPARKS,
            TE_BLASTER2,
            TE_RAILTRAIL2,
            TE_FLAME,
            TE_LIGHTNING,
            TE_DEBUGTRAIL,
            TE_PLAIN_EXPLOSION,
            TE_FLASHLIGHT,
            TE_FORCEWALL,
            TE_HEATBEAM,
            TE_MONSTER_HEATBEAM,
            TE_STEAM,
            TE_BUBBLETRAIL2,
            TE_MOREBLOOD,
            TE_HEATBEAM_SPARKS,
            TE_HEATBEAM_STEAM,
            TE_CHAINFIST_SMOKE,
            TE_ELECTRIC_SPARKS,
            TE_TRACKER_EXPLOSION,
            TE_TELEPORT_EFFECT,
            TE_DBALL_GOAL,
            TE_WIDOWBEAMOUT,
            TE_NUKEBLAST,
            TE_WIDOWSPLASH,
            TE_EXPLOSION1_BIG,
            TE_EXPLOSION1_NP,
            TE_FLECHETTE
        }

        public const int SPLASH_UNKNOWN = 0;
        public const int SPLASH_SPARKS = 1;
        public const int SPLASH_BLUE_WATER = 2;
        public const int SPLASH_BROWN_WATER = 3;
        public const int SPLASH_SLIME = 4;
        public const int SPLASH_LAVA = 5;
        public const int SPLASH_BLOOD = 6;

        /* sound channels:
        * channel 0 never willingly overrides
        * other channels (1-7) allways override
        * a playing sound on that channel */
        public const int CHAN_AUTO = 0;
        public const int CHAN_WEAPON = 1;
        public const int CHAN_VOICE = 2;
        public const int CHAN_ITEM = 3;
        public const int CHAN_BODY = 4;
        /* modifier flags */
        public const int CHAN_NO_PHS_ADD = 8;           /* send to all clients, not just ones in PHS (ATTN 0 will also do this) */
        public const int CHAN_RELIABLE = 16;            /* send by reliable message, not datagram */

        /* sound attenuation values */
        public const int ATTN_NONE = 0;                 /* full volume the entire level */
        public const int ATTN_NORM = 1;
        public const int ATTN_IDLE = 2;
        public const int ATTN_STATIC = 3;               /* diminish very rapidly with distance */

        /* player_state->stats[] indexes */
        public const int STAT_HEALTH_ICON = 0;
        public const int STAT_HEALTH = 1;
        public const int STAT_AMMO_ICON = 2;
        public const int STAT_AMMO = 3;
        public const int STAT_ARMOR_ICON = 4;
        public const int STAT_ARMOR = 5;
        public const int STAT_SELECTED_ICON = 6;
        public const int STAT_PICKUP_ICON = 7;
        public const int STAT_PICKUP_STRING = 8;
        public const int STAT_TIMER_ICON = 9;
        public const int STAT_TIMER = 10;
        public const int STAT_HELPICON = 11;
        public const int STAT_SELECTED_ITEM = 12;
        public const int STAT_LAYOUTS = 13;
        public const int STAT_FRAGS = 14;
        public const int STAT_FLASHES = 15;                 /* cleared each frame, 1 = health, 2 = armor */
        public const int STAT_CHASE = 16;
        public const int STAT_SPECTATOR = 17;

        public const int MAX_STATS = 32;

        /* dmflags->value flags */
        public const int DF_NO_HEALTH = 0x00000001;         /* 1 */
        public const int DF_NO_ITEMS = 0x00000002;          /* 2 */
        public const int DF_WEAPONS_STAY = 0x00000004;      /* 4 */
        public const int DF_NO_FALLING = 0x00000008;        /* 8 */
        public const int DF_INSTANT_ITEMS = 0x00000010;     /* 16 */
        public const int DF_SAME_LEVEL = 0x00000020;        /* 32 */
        public const int DF_SKINTEAMS = 0x00000040;         /* 64 */
        public const int DF_MODELTEAMS = 0x00000080;        /* 128 */
        public const int DF_NO_FRIENDLY_FIRE = 0x00000100;  /* 256 */
        public const int DF_SPAWN_FARTHEST = 0x00000200;    /* 512 */
        public const int DF_FORCE_RESPAWN = 0x00000400;     /* 1024 */
        public const int DF_NO_ARMOR = 0x00000800;          /* 2048 */
        public const int DF_ALLOW_EXIT = 0x00001000;        /* 4096 */
        public const int DF_INFINITE_AMMO = 0x00002000;     /* 8192 */
        public const int DF_QUAD_DROP = 0x00004000;         /* 16384 */
        public const int DF_FIXED_FOV = 0x00008000;         /* 32768 */
        public const int DF_QUADFIRE_DROP = 0x00010000;     /* 65536 */
        public const int DF_NO_MINES = 0x00020000;
        public const int DF_NO_STACK_DOUBLE = 0x00040000;
        public const int DF_NO_NUKES = 0x00080000;
        public const int DF_NO_SPHERES = 0x00100000;

        public const string ROGUE_VERSION_STRING = "08/21/1998 Beta 2 for Ensemble";
        /*
        * ==========================================================
        *
        * ELEMENTS COMMUNICATED ACROSS THE NET
        *
        * ==========================================================
        */

        public static short ANGLE2SHORT(float x)  => (short)((int)((x) * 65536.0f / 360) & 65535);
        public static float SHORT2ANGLE(int x) => (float)((x) * (360.0 / 65536));

        /* config strings are a general means of communication from
        * the server to all connected clients. Each config string
        * can be at most MAX_QPATH characters. */
        public static int CS_NAME = 0;
        public static int CS_CDTRACK = 1;
        public static int CS_SKY = 2;
        public static int CS_SKYAXIS = 3;                /* %f %f %f format */
        public static int CS_SKYROTATE = 4;
        public static int CS_STATUSBAR = 5;              /* display program string */

        public static int CS_AIRACCEL = 29;              /* air acceleration control */
        public static int CS_MAXCLIENTS = 30;
        public static int CS_MAPCHECKSUM = 31;           /* for catching cheater maps */

        public static int CS_MODELS = 32;
        public static int CS_SOUNDS = (CS_MODELS + MAX_MODELS);
        public static int CS_IMAGES = (CS_SOUNDS + MAX_SOUNDS);
        public static int CS_LIGHTS = (CS_IMAGES + MAX_IMAGES);
        public static int CS_ITEMS = (CS_LIGHTS + MAX_LIGHTSTYLES);
        public static int CS_PLAYERSKINS = (CS_ITEMS + MAX_ITEMS);
        public static int CS_GENERAL = (CS_PLAYERSKINS + MAX_CLIENTS);
        public static int MAX_CONFIGSTRINGS = (CS_GENERAL + MAX_GENERAL);


        /* ============================================== */

        /* entity_state_t->event values
        * entity events are for effects that take place reletive
        * to an existing entities origin.  Very network efficient.
        * All muzzle flashes really should be converted to events... */
        internal enum entity_event_t
        {
            EV_NONE = 0,
            EV_ITEM_RESPAWN,
            EV_FOOTSTEP,
            EV_FALLSHORT,
            EV_FALL,
            EV_FALLFAR,
            EV_PLAYER_TELEPORT,
            EV_OTHER_TELEPORT
        }

        /* entity_state_t is the information conveyed from the server
        * in an update message about entities that the client will
        * need to render in some way */
        internal class entity_state_t : ICloneable
        {
            public int number;             /* edict index */

            public Vector3 origin;
            public Vector3 angles;
            public Vector3 old_origin;      /* for lerping */
            public int modelindex;
            public int modelindex2, modelindex3, modelindex4;      /* weapons, CTF flags, etc */
            public int frame;
            public int skinnum;
            public uint effects;
            public int renderfx;
            public int solid;              /* for client side prediction, 8*(bits 0-4) is x/y radius */
                                    /* 8*(bits 5-9) is z down distance, 8(bits10-15) is z up */
                                    /* gi.linkentity sets this properly */
            public int sound;              /* for looping sounds, to guarantee shutoff */
            public int ev;              /* impulse events -- muzzle flashes, footsteps, etc */
                                    /* events only go out for a single frame, they */
                                    /* are automatically cleared each frame */

            public object Clone()
            {
                return MemberwiseClone();
            }

        }

        /* ============================================== */

        /* player_state_t is the information needed in addition to pmove_state_t
        * to rendered a view.  There will only be 10 player_state_t sent each second,
        * but the number of pmove_state_t changes will be reletive to client
        * frame rates */
        public class player_state_t : ICloneable
        {
            public pmove_state_t pmove;        /* for prediction */

            public Vector3 viewangles;          /* for fixed views */
            public Vector3 viewoffset;          /* add to pmovestate->origin */
            public Vector3 kick_angles;         /* add to view direction to get render angles */
                                        /* set by weapon kicks, pain effects, etc */

            public Vector3 gunangles;
            public Vector3 gunoffset;
            public int gunindex;
            public int gunframe;

            public float[] blend = new float[4];             /* rgba full screen effect */
            public float fov;                  /* horizontal field of view */
            public int rdflags;                /* refdef flags */

            public short[] stats = new short[MAX_STATS];     /* fast status bar updates */

            public object Clone()
            {
                var state = (player_state_t)MemberwiseClone();
                Array.Copy(blend, state.blend, 4);
                Array.Copy(stats, state.stats, MAX_STATS);
                return state;
            }

        }


        public static Random rand = new Random();

        public static int randk() {
            return rand.Next();
        }

        public static System.Globalization.NumberFormatInfo provider = new System.Globalization.NumberFormatInfo();
        
        public static float ToRadians(float Degrees) => Degrees * (MathF.PI / 180.0f);

        public static Vector3 vec3_origin = new Vector3(0, 0, 0);

        /* ============================================================================ */

        public static Vector3 RotatePointAroundVector(in Vector3 dir, in Vector3 point, float degrees)
        {
            // float m[3][3];
            // float im[3][3];
            // float zrot[3][3];
            // float tmpmat[3][3];
            // float rot[3][3];
            // int i;
            // vec3_t vr, vup, vf;

            var vf = dir;

            var vr = PerpendicularVector(dir);
            var vup = Vector3.Cross(vr, vf);

            var m = new Matrix3X3<float>(
                vr.X, vup.X, vf.X,
                vr.Y, vup.Y, vf.Y,
                vr.Z, vup.Z, vf.Z
            );

            // m[0][0] = vr[0];
            // m[1][0] = vr[1];
            // m[2][0] = vr[2];

            // m[0][1] = vup[0];
            // m[1][1] = vup[1];
            // m[2][1] = vup[2];

            // m[0][2] = vf[0];
            // m[1][2] = vf[1];
            // m[2][2] = vf[2];

            var im = m;

            im.M12 = m.M21;
            im.M13 = m.M31;
            im.M21 = m.M12;
            im.M23 = m.M31;
            im.M31 = m.M13;
            im.M32 = m.M23;

            var zrot = new Matrix3X3<float>();
            zrot.M33 = 1.0F;

            zrot.M11 = MathF.Cos(ToRadians(degrees));
            zrot.M12 = MathF.Sin(ToRadians(degrees));
            zrot.M21 = -MathF.Sin(ToRadians(degrees));
            zrot.M22 = MathF.Cos(ToRadians(degrees));

            var tmpmat = R_ConcatRotations(m, zrot);
            var rot = R_ConcatRotations(tmpmat, im);

            return new Vector3(
                rot.M11 * point.X + rot.M12 * point.Y + rot.M13 * point.Z,
                rot.M21 * point.X + rot.M22 * point.Y + rot.M23 * point.Z,
                rot.M31 * point.X + rot.M32 * point.Y + rot.M33 * point.Z
            );
        }

        public static void AngleVectors(in Vector3 angles, ref Vector3 forward, ref Vector3 right, ref Vector3 up)
        {
            // float angle;
            // static float sr, sp, sy, cr, cp, cy;

            var angle = angles.Yaw() * (MathF.PI * 2 / 360);
            var sy = MathF.Sin(angle);
            var cy = MathF.Cos(angle);
            angle = angles.Pitch() * (MathF.PI * 2 / 360);
            var sp = MathF.Sin(angle);
            var cp = MathF.Cos(angle);
            angle = angles.Roll() * (MathF.PI * 2 / 360);
            var sr = MathF.Sin(angle);
            var cr = MathF.Cos(angle);

            forward.X = cp * cy;
            forward.Y = cp * sy;
            forward.Z = -sp;

            right.X = (-1 * sr * sp * cy + - 1 * cr * -sy);
            right.Y = (-1 * sr * sp * sy + - 1 * cr * cy);
            right.Z = -1 * sr * cp;

            up.X = (cr * sp * cy + - sr * -sy);
            up.Y = (cr * sp * sy + - sr * cy);
            up.Z = cr * cp;
        }

        public static Vector3 ProjectPointOnPlane(in Vector3 p, in Vector3 normal)
        {
            float inv_denom = 1.0F / Vector3.Dot(normal, normal);

            float d = Vector3.Dot(normal, p) * inv_denom;

            var n = normal * inv_denom;

            return p - d * n;
        }

        /* assumes "src" is normalized */
        public static Vector3 PerpendicularVector(in Vector3 src)
        {
            int pos = 0;
            // int i;
            float minelem = 1.0F;
            // vec3_t tempvec;

            /* find the smallest magnitude axially aligned vector */
            if (MathF.Abs(src.X) < minelem) {
                pos = 0;
                minelem = MathF.Abs(src.X);
            }
            if (MathF.Abs(src.Y) < minelem) {
                pos = 1;
                minelem = MathF.Abs(src.Y);
            }
            if (MathF.Abs(src.Z) < minelem) {
                pos = 2;
                minelem = MathF.Abs(src.Z);
            }
            var tempvec = new Vector3();
            if (pos == 0)
                tempvec.X = 1.0F;
            else if (pos == 1)
                tempvec.Y = 1.0F;
            else
                tempvec.Z = 1.0F;

            /* project the point onto the plane defined by src */
            var dst = ProjectPointOnPlane(tempvec, src);

            /* normalize the result */
            return Vector3.Normalize(dst);
        }

        public static Matrix3X3<float> R_ConcatRotations(in Matrix3X3<float> in1, in Matrix3X3<float> in2)
        {
            var res = new Matrix3X3<float>();
            res.M11 = in1.M11 * in2.M11 + in1.M12 * in2.M21 + in1.M13 * in2.M31;
            res.M12 = in1.M11 * in2.M12 + in1.M12 * in2.M22 + in1.M13 * in2.M32;
            res.M13 = in1.M11 * in2.M13 + in1.M12 * in2.M23 + in1.M13 * in2.M33;
            res.M21 = in1.M21 * in2.M11 + in1.M22 * in2.M21 + in1.M23 * in2.M31;
            res.M22 = in1.M21 * in2.M12 + in1.M22 * in2.M22 + in1.M23 * in2.M32;
            res.M23 = in1.M21 * in2.M13 + in1.M22 * in2.M23 + in1.M23 * in2.M33;
            res.M31 = in1.M31 * in2.M11 + in1.M32 * in2.M21 + in1.M33 * in2.M31;
            res.M32 = in1.M31 * in2.M12 + in1.M32 * in2.M22 + in1.M33 * in2.M32;
            res.M33 = in1.M31 * in2.M13 + in1.M32 * in2.M23 + in1.M33 * in2.M33;
            return res;
        }

        public static float LerpAngle(float a2, float a1, float frac)
        {
            if (a1 - a2 > 180)
            {
                a1 -= 360;
            }

            if (a1 - a2 < -180)
            {
                a1 += 360;
            }

            return a2 + frac * (a1 - a2);
        }


        public static Vector3 LerpAngles(Vector3 a2, Vector3 a1, float frac)
        {
            return new Vector3(
                LerpAngle(a2.X, a1.X, frac),
                LerpAngle(a2.Y, a1.Y, frac),
                LerpAngle(a2.Z, a1.Z, frac)
            );
        }

        public static float anglemod(float a)
        {
            return (360.0f / 65536) * ((int)(a * (65536 / 360.0)) & 65535);
        }

        /*
        * Returns 1, 2, or 1 + 2
        */
        public static int BoxOnPlaneSide(in Vector3 emins, in Vector3 emaxs, in cplane_t p)
        {
            /* fast axial cases */
            switch (p.type)
            {
                case 0:
                    if (p.dist <= emins.X)
                    {
                        return 1;
                    }

                    if (p.dist >= emaxs.X)
                    {
                        return 2;
                    }
                    return 3;
                case 1:
                    if (p.dist <= emins.Y)
                    {
                        return 1;
                    }

                    if (p.dist >= emaxs.Y)
                    {
                        return 2;
                    }
                    return 3;
                case 2:
                    if (p.dist <= emins.Z)
                    {
                        return 1;
                    }

                    if (p.dist >= emaxs.Z)
                    {
                        return 2;
                    }
                    return 3;
                default:
                    /* general case */
                    float dist1, dist2;

                    switch (p.signbits)
                    {
                        case 0:
                            dist1 = p.normal.X * emaxs.X + p.normal.Y * emaxs.Y +
                                    p.normal.Z * emaxs.Z;
                            dist2 = p.normal.X * emins.X + p.normal.Y * emins.Y +
                                    p.normal.Z * emins.Z;
                            break;
                        case 1:
                            dist1 = p.normal.X * emins.X + p.normal.Y * emaxs.Y +
                                    p.normal.Z * emaxs.Z;
                            dist2 = p.normal.X * emaxs.X + p.normal.Y * emins.Y +
                                    p.normal.Z * emins.Z;
                            break;
                        case 2:
                            dist1 = p.normal.X * emaxs.X + p.normal.Y * emins.Y +
                                    p.normal.Z * emaxs.Z;
                            dist2 = p.normal.X * emins.X + p.normal.Y * emaxs.Y +
                                    p.normal.Z * emins.Z;
                            break;
                        case 3:
                            dist1 = p.normal.X * emins.X + p.normal.Y * emins.Y +
                                    p.normal.Z * emaxs.Z;
                            dist2 = p.normal.X * emaxs.X + p.normal.Y * emaxs.Y +
                                    p.normal.Z * emins.Z;
                            break;
                        case 4:
                            dist1 = p.normal.X * emaxs.X + p.normal.Y * emaxs.Y +
                                    p.normal.Z * emins.Z;
                            dist2 = p.normal.X * emins.X + p.normal.Y * emins.Y +
                                    p.normal.Z * emaxs.Z;
                            break;
                        case 5:
                            dist1 = p.normal.X * emins.X + p.normal.Y * emaxs.Y +
                                    p.normal.Z * emins.Z;
                            dist2 = p.normal.X * emaxs.X + p.normal.Y * emins.Y +
                                    p.normal.Z * emaxs.Z;
                            break;
                        case 6:
                            dist1 = p.normal.X * emaxs.X + p.normal.Y * emins.Y +
                                    p.normal.Z * emins.Z;
                            dist2 = p.normal.X * emins.X + p.normal.Y * emaxs.Y +
                                    p.normal.Z * emaxs.Z;
                            break;
                        case 7:
                            dist1 = p.normal.X * emins.X + p.normal.Y * emins.Y +
                                    p.normal.Z * emins.Z;
                            dist2 = p.normal.X * emaxs.X + p.normal.Y * emaxs.Y +
                                    p.normal.Z * emaxs.Z;
                            break;
                        default:
                            dist1 = dist2 = 0;
                            break;
                    }
                    int sides = 0;

                    if (dist1 >= p.dist)
                    {
                        sides = 1;
                    }

                    if (dist2 < p.dist)
                    {
                        sides |= 2;
                    }

                    return sides;
            }
        }

        /*
        * Parse a token out of a string
        */
        public static string COM_Parse(string data, ref int index)
        {
        //     int c;
        //     int len;
        //     char *data;

        //     data = *data_p;
        //     len = 0;
        //     com_token[0] = 0;

            if (String.IsNullOrEmpty(data) || index < 0 || index >= data.Length)
            {
                index = -1;
                return "";
            }

            while (index < data.Length && data[index] <= ' ')
            {
                index++;
            }

            /* skip // comments */
            if ((index + 1) < data.Length && (data[index] == '/') && (data[index + 1] == '/'))
            {
                while (index < data.Length && data[index] != '\n')
                {
                    index++;
                }

                return COM_Parse(data, ref index);
            }

            if (index >= data.Length)
            {
                index = -1;
                return "";
            }

            var com_token = new StringBuilder();

            /* handle quoted strings specially */
            if (data[index] == '\"')
            {
                index++;

                while (true)
                {
                    if (index >= data.Length) {
                        return com_token.ToString();
                    }
                    var c = data[index++];

                    if (c == '\"')
                    {
                        return com_token.ToString();
                    }
                    com_token.Append(c);
                }
            }

            /* parse a regular word */
            while (true)
            {
                com_token.Append(data[index++]);
                if (index >= data.Length)
                {
                    return com_token.ToString();
                }
                if (data[index] <= ' ')
                {
                    return com_token.ToString();
                }
            }
        }

        /*
        * =====================================================================
        *
        * INFO STRINGS
        *
        * =====================================================================
        */

        /*
        * Searches the string for the given
        * key and returns the associated value,
        * or an empty string.
        */
        public static string Info_ValueForKey(in string s, in string key)
        {
            if (String.IsNullOrEmpty(s))
            {
                return "";
            }
            if (String.IsNullOrEmpty(key))
            {
                return "";
            }
            string[] splits = s.Split('\\');
            if (splits.Length < 1) {
                return "";
            }
            for (int i = 1; i < splits.Length; i += 2)
            {
                if (splits[i].Equals(key))
                {
                    return splits[i+1];
                }
            }
            return "";
        }

        public static string Info_RemoveKey(in string s, in string key)
        {
            if (String.IsNullOrEmpty(s))
            {
                return "";
            }
            if (String.IsNullOrEmpty(key))
            {
                return s;
            }
            string[] splits = s.Split('\\');
            if (splits.Length < 1) 
            {
                return s;
            }
            if (!splits.Contains(key))
            {
                return s;
            }
            var sb = new StringBuilder();
            for (int i = 1; i < splits.Length; i += 2)
            {
                if (!splits[i].Equals(key))
                {
                    sb.Append($"\\{splits[i]}\\{splits[i+1]}");
                }
            }
            return sb.ToString();
        }

        /*
        * Some characters are illegal in info strings
        * because they can mess up the server's parsing
        */
        public static bool Info_Validate(in string s)
        {
            if (s.Contains("\""))
            {
                return false;
            }

            if (s.Contains(";"))
            {
                return false;
            }

            return true;
        }

        public static string Info_SetValueForKey(QCommon common, in string s, in string key, in string? value)
        {
            if (String.IsNullOrEmpty(key))
            {
                return s;
            }
            if (key.Contains("\\") || (value?.Contains("\\") ?? false))
            {
                common.Com_Printf("Can't use keys or values with a \\\n");
                return s;
            }

            if (key.Contains(";"))
            {
                common.Com_Printf("Can't use keys with a semicolon\n");
                return s;
            }

            if (key.Contains("\"") || (value?.Contains("\"") ?? false))
            {
                common.Com_Printf("Can't use keys or values with a \"\n");
                return s;
            }

            var s1 = Info_RemoveKey(s, key);

            if (String.IsNullOrEmpty(value))
            {
                return s1;
            }

            return s1 + $"\\{key}\\{value}";
        }

        internal static readonly Vector3[] bytedirs = {
            new Vector3(-0.525731f, 0.000000f, 0.850651f),
            new Vector3(-0.442863f, 0.238856f, 0.864188f),
            new Vector3(-0.295242f, 0.000000f, 0.955423f),
            new Vector3(-0.309017f, 0.500000f, 0.809017f),
            new Vector3(-0.162460f, 0.262866f, 0.951056f),
            new Vector3(0.000000f, 0.000000f, 1.000000f),
            new Vector3(0.000000f, 0.850651f, 0.525731f),
            new Vector3(-0.147621f, 0.716567f, 0.681718f),
            new Vector3(0.147621f, 0.716567f, 0.681718f),
            new Vector3(0.000000f, 0.525731f, 0.850651f),
            new Vector3(0.309017f, 0.500000f, 0.809017f),
            new Vector3(0.525731f, 0.000000f, 0.850651f),
            new Vector3(0.295242f, 0.000000f, 0.955423f),
            new Vector3(0.442863f, 0.238856f, 0.864188f),
            new Vector3(0.162460f, 0.262866f, 0.951056f),
            new Vector3(-0.681718f, 0.147621f, 0.716567f),
            new Vector3(-0.809017f, 0.309017f, 0.500000f),
            new Vector3(-0.587785f, 0.425325f, 0.688191f),
            new Vector3(-0.850651f, 0.525731f, 0.000000f),
            new Vector3(-0.864188f, 0.442863f, 0.238856f),
            new Vector3(-0.716567f, 0.681718f, 0.147621f),
            new Vector3(-0.688191f, 0.587785f, 0.425325f),
            new Vector3(-0.500000f, 0.809017f, 0.309017f),
            new Vector3(-0.238856f, 0.864188f, 0.442863f),
            new Vector3(-0.425325f, 0.688191f, 0.587785f),
            new Vector3(-0.716567f, 0.681718f, -0.147621f),
            new Vector3(-0.500000f, 0.809017f, -0.309017f),
            new Vector3(-0.525731f, 0.850651f, 0.000000f),
            new Vector3(0.000000f, 0.850651f, -0.525731f),
            new Vector3(-0.238856f, 0.864188f, -0.442863f),
            new Vector3(0.000000f, 0.955423f, -0.295242f),
            new Vector3(-0.262866f, 0.951056f, -0.162460f),
            new Vector3(0.000000f, 1.000000f, 0.000000f),
            new Vector3(0.000000f, 0.955423f, 0.295242f),
            new Vector3(-0.262866f, 0.951056f, 0.162460f),
            new Vector3(0.238856f, 0.864188f, 0.442863f),
            new Vector3(0.262866f, 0.951056f, 0.162460f),
            new Vector3(0.500000f, 0.809017f, 0.309017f),
            new Vector3(0.238856f, 0.864188f, -0.442863f),
            new Vector3(0.262866f, 0.951056f, -0.162460f),
            new Vector3(0.500000f, 0.809017f, -0.309017f),
            new Vector3(0.850651f, 0.525731f, 0.000000f),
            new Vector3(0.716567f, 0.681718f, 0.147621f),
            new Vector3(0.716567f, 0.681718f, -0.147621f),
            new Vector3(0.525731f, 0.850651f, 0.000000f),
            new Vector3(0.425325f, 0.688191f, 0.587785f),
            new Vector3(0.864188f, 0.442863f, 0.238856f),
            new Vector3(0.688191f, 0.587785f, 0.425325f),
            new Vector3(0.809017f, 0.309017f, 0.500000f),
            new Vector3(0.681718f, 0.147621f, 0.716567f),
            new Vector3(0.587785f, 0.425325f, 0.688191f),
            new Vector3(0.955423f, 0.295242f, 0.000000f),
            new Vector3(1.000000f, 0.000000f, 0.000000f),
            new Vector3(0.951056f, 0.162460f, 0.262866f),
            new Vector3(0.850651f, -0.525731f, 0.000000f),
            new Vector3(0.955423f, -0.295242f, 0.000000f),
            new Vector3(0.864188f, -0.442863f, 0.238856f),
            new Vector3(0.951056f, -0.162460f, 0.262866f),
            new Vector3(0.809017f, -0.309017f, 0.500000f),
            new Vector3(0.681718f, -0.147621f, 0.716567f),
            new Vector3(0.850651f, 0.000000f, 0.525731f),
            new Vector3(0.864188f, 0.442863f, -0.238856f),
            new Vector3(0.809017f, 0.309017f, -0.500000f),
            new Vector3(0.951056f, 0.162460f, -0.262866f),
            new Vector3(0.525731f, 0.000000f, -0.850651f),
            new Vector3(0.681718f, 0.147621f, -0.716567f),
            new Vector3(0.681718f, -0.147621f, -0.716567f),
            new Vector3(0.850651f, 0.000000f, -0.525731f),
            new Vector3(0.809017f, -0.309017f, -0.500000f),
            new Vector3(0.864188f, -0.442863f, -0.238856f),
            new Vector3(0.951056f, -0.162460f, -0.262866f),
            new Vector3(0.147621f, 0.716567f, -0.681718f),
            new Vector3(0.309017f, 0.500000f, -0.809017f),
            new Vector3(0.425325f, 0.688191f, -0.587785f),
            new Vector3(0.442863f, 0.238856f, -0.864188f),
            new Vector3(0.587785f, 0.425325f, -0.688191f),
            new Vector3(0.688191f, 0.587785f, -0.425325f),
            new Vector3(-0.147621f, 0.716567f, -0.681718f),
            new Vector3(-0.309017f, 0.500000f, -0.809017f),
            new Vector3(0.000000f, 0.525731f, -0.850651f),
            new Vector3(-0.525731f, 0.000000f, -0.850651f),
            new Vector3(-0.442863f, 0.238856f, -0.864188f),
            new Vector3(-0.295242f, 0.000000f, -0.955423f),
            new Vector3(-0.162460f, 0.262866f, -0.951056f),
            new Vector3(0.000000f, 0.000000f, -1.000000f),
            new Vector3(0.295242f, 0.000000f, -0.955423f),
            new Vector3(0.162460f, 0.262866f, -0.951056f),
            new Vector3(-0.442863f, -0.238856f, -0.864188f),
            new Vector3(-0.309017f, -0.500000f, -0.809017f),
            new Vector3(-0.162460f, -0.262866f, -0.951056f),
            new Vector3(0.000000f, -0.850651f, -0.525731f),
            new Vector3(-0.147621f, -0.716567f, -0.681718f),
            new Vector3(0.147621f, -0.716567f, -0.681718f),
            new Vector3(0.000000f, -0.525731f, -0.850651f),
            new Vector3(0.309017f, -0.500000f, -0.809017f),
            new Vector3(0.442863f, -0.238856f, -0.864188f),
            new Vector3(0.162460f, -0.262866f, -0.951056f),
            new Vector3(0.238856f, -0.864188f, -0.442863f),
            new Vector3(0.500000f, -0.809017f, -0.309017f),
            new Vector3(0.425325f, -0.688191f, -0.587785f),
            new Vector3(0.716567f, -0.681718f, -0.147621f),
            new Vector3(0.688191f, -0.587785f, -0.425325f),
            new Vector3(0.587785f, -0.425325f, -0.688191f),
            new Vector3(0.000000f, -0.955423f, -0.295242f),
            new Vector3(0.000000f, -1.000000f, 0.000000f),
            new Vector3(0.262866f, -0.951056f, -0.162460f),
            new Vector3(0.000000f, -0.850651f, 0.525731f),
            new Vector3(0.000000f, -0.955423f, 0.295242f),
            new Vector3(0.238856f, -0.864188f, 0.442863f),
            new Vector3(0.262866f, -0.951056f, 0.162460f),
            new Vector3(0.500000f, -0.809017f, 0.309017f),
            new Vector3(0.716567f, -0.681718f, 0.147621f),
            new Vector3(0.525731f, -0.850651f, 0.000000f),
            new Vector3(-0.238856f, -0.864188f, -0.442863f),
            new Vector3(-0.500000f, -0.809017f, -0.309017f),
            new Vector3(-0.262866f, -0.951056f, -0.162460f),
            new Vector3(-0.850651f, -0.525731f, 0.000000f),
            new Vector3(-0.716567f, -0.681718f, -0.147621f),
            new Vector3(-0.716567f, -0.681718f, 0.147621f),
            new Vector3(-0.525731f, -0.850651f, 0.000000f),
            new Vector3(-0.500000f, -0.809017f, 0.309017f),
            new Vector3(-0.238856f, -0.864188f, 0.442863f),
            new Vector3(-0.262866f, -0.951056f, 0.162460f),
            new Vector3(-0.864188f, -0.442863f, 0.238856f),
            new Vector3(-0.809017f, -0.309017f, 0.500000f),
            new Vector3(-0.688191f, -0.587785f, 0.425325f),
            new Vector3(-0.681718f, -0.147621f, 0.716567f),
            new Vector3(-0.442863f, -0.238856f, 0.864188f),
            new Vector3(-0.587785f, -0.425325f, 0.688191f),
            new Vector3(-0.309017f, -0.500000f, 0.809017f),
            new Vector3(-0.147621f, -0.716567f, 0.681718f),
            new Vector3(-0.425325f, -0.688191f, 0.587785f),
            new Vector3(-0.162460f, -0.262866f, 0.951056f),
            new Vector3(0.442863f, -0.238856f, 0.864188f),
            new Vector3(0.162460f, -0.262866f, 0.951056f),
            new Vector3(0.309017f, -0.500000f, 0.809017f),
            new Vector3(0.147621f, -0.716567f, 0.681718f),
            new Vector3(0.000000f, -0.525731f, 0.850651f),
            new Vector3(0.425325f, -0.688191f, 0.587785f),
            new Vector3(0.587785f, -0.425325f, 0.688191f),
            new Vector3(0.688191f, -0.587785f, 0.425325f),
            new Vector3(-0.955423f, 0.295242f, 0.000000f),
            new Vector3(-0.951056f, 0.162460f, 0.262866f),
            new Vector3(-1.000000f, 0.000000f, 0.000000f),
            new Vector3(-0.850651f, 0.000000f, 0.525731f),
            new Vector3(-0.955423f, -0.295242f, 0.000000f),
            new Vector3(-0.951056f, -0.162460f, 0.262866f),
            new Vector3(-0.864188f, 0.442863f, -0.238856f),
            new Vector3(-0.951056f, 0.162460f, -0.262866f),
            new Vector3(-0.809017f, 0.309017f, -0.500000f),
            new Vector3(-0.864188f, -0.442863f, -0.238856f),
            new Vector3(-0.951056f, -0.162460f, -0.262866f),
            new Vector3(-0.809017f, -0.309017f, -0.500000f),
            new Vector3(-0.681718f, 0.147621f, -0.716567f),
            new Vector3(-0.681718f, -0.147621f, -0.716567f),
            new Vector3(-0.850651f, 0.000000f, -0.525731f),
            new Vector3(-0.688191f, 0.587785f, -0.425325f),
            new Vector3(-0.587785f, 0.425325f, -0.688191f),
            new Vector3(-0.425325f, 0.688191f, -0.587785f),
            new Vector3(-0.425325f, -0.688191f, -0.587785f),
            new Vector3(-0.587785f, -0.425325f, -0.688191f),
            new Vector3(-0.688191f, -0.587785f, -0.425325f)
        };
    }

    public static class RollYawPitch
    {
        public static float Pitch(this Vector3 v)
        {
            return v.X;
        }
        public static float Yaw(this Vector3 v)
        {
            return v.Y;
        }
        public static float Roll(this Vector3 v)
        {
            return v.Z;
        }
        public static void SetPitch(this Vector3 v, float value)
        {
            v.X = value;
        }
        public static void SetYaw(this Vector3 v, float value)
        {
            v.Y = value;
        }
        public static void SetRoll(this Vector3 v, float value)
        {
            v.Z = value;
        }

    }        

}
