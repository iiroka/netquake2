/*
 * Copyright (C) 1997-2001 Id Software, Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
 * USA.
 *
 * =======================================================================
 *
 * Main header for the client
 *
 * =======================================================================
 */
using System.Numerics;

namespace Quake2 {

    partial class QClient {

        private const int MAX_CLIENTWEAPONMODELS = 20;
        private const int CMD_BACKUP = 256; /* allow a lot of command backups for very fast systems */

        /* the cl_parse_entities must be large enough to hold UPDATE_BACKUP frames of
        entities, so that when a delta compressed message arives from the server
        it can be un-deltad from the original */
        private const int MAX_PARSE_ENTITIES	= 1024;

        private const int PARTICLE_GRAVITY = 40;
        private const float INSTANT_PARTICLE = -10000.0f;


        private class frame_t : ICloneable
        {
            public bool		valid; /* cleared if delta parsing was invalid */
            public int				serverframe;
            public int				servertime; /* server time the message is valid for (in msec) */
            public int				deltaframe;
            public byte[]			areabits = new byte[0]; /* portalarea visibility bits */
            public QShared.player_state_t	playerstate = new QShared.player_state_t();
            public int				num_entities;
            public int				parse_entities; /* non-masked index into cl_parse_entities array */

            public object Clone()
            {
                var frame = (frame_t)MemberwiseClone();
                frame.areabits = new byte[areabits.Length];
                Array.Copy(areabits, frame.areabits, areabits.Length);
                frame.playerstate = (QShared.player_state_t)playerstate.Clone();
                return frame;
            }

        }

        private struct centity_t
        {
            public QShared.entity_state_t	baseline; /* delta from this if not from a previous frame */
            public QShared.entity_state_t	current;
            public QShared.entity_state_t	prev; /* will always be valid, but might just be a copy of current */

            public int			serverframe; /* if not current, this ent isn't in the frame */

            public int			trailcount;	 /* for diminishing grenade trails */
            public Vector3		lerp_origin; /* for trails (variable hz) */

            public int			fly_stoptime;
        }

        private struct clientinfo_t
        {
            public string	name;
            public string	cinfo;

            public image_s?	skin;

            public image_s?	icon;
            public string	iconname;

            public model_s?	model;

            public model_s?[]    weaponmodel;
        }


        /* the client_state_t structure is wiped
        completely at every server map change */
        private struct client_state_t
        {
            public int			timeoutcount;

            public int			timedemo_frames;
            public int			timedemo_start;

            public bool	refresh_prepped; /* false if on new level or new ref dll */
            public bool	sound_prepped; /* ambient sounds can start */
            public bool	force_refdef; /* vid has changed, so we can't use a paused refdef */

            public int			parse_entities; /* index (not anded off) into cl_parse_entities[] */

            public QShared.usercmd_t	cmd;
            public QShared.usercmd_t[]	cmds; /* each mesage will send several old cmds */
            // public int			cmd_time[CMD_BACKUP]; /* time sent, for calculating pings */
            public short[][]		predicted_origins; // [CMD_BACKUP][3]; /* for debug comparing against server */

            public float		predicted_step; /* for stair up smoothing */
            public uint	predicted_step_time;

            public Vector3		predicted_origin; /* generated by CL_PredictMovement */
            public Vector3		predicted_angles;
            public Vector3		prediction_error;

            public frame_t		frame; /* received from server */
            public int			surpressCount; /* number of messages rate supressed */
            public frame_t[]    frames;

            // /* the client maintains its own idea of view angles, which are
            // sent to the server each frame.  It is cleared to 0 upon entering each level.
            // the server sends a delta each frame which is added to the locally
            // tracked view angles to account for standing on rotating objects,
            // and teleport direction changes */
            public Vector3		viewangles;

            public int			time; /* this is the time value that the client is rendering at. always <= cls.realtime */
            public float		lerpfrac; /* between oldframe and frame */

            public refdef_t	refdef;

            public Vector3		v_forward, v_right, v_up; /* set when refdef.angles is set */

            /* transient data from server */
            public string layout; /* general 2D overlay */
            // public int			inventory[MAX_ITEMS];

            /* non-gameserver infornamtion */
            public QCommon.IFileHandle? cinematic_file;
            public int			cinematictime; /* cls.realtime for first cinematic frame */
            public int			cinematicframe;
            // public unsigned char	cinematicpalette[768];
            // public qboolean	cinematicpalette_active;

            // /* server state information */
            public bool	        attractloop; /* running the attract loop, any key will menu */
            public int			servercount; /* server identification for prespawns */
            public string	    gamedir;
            public int			playernum;

            public string[]     configstrings;

            // /* locally derived information from server state */

            public model_s?[] model_draw;

            public QShared.cmodel_t?[] model_clip;
            // public struct cmodel_s	*model_clip[MAX_MODELS];

            // public struct sfx_s	*sound_precache[MAX_SOUNDS];

            public image_s?[]	image_precache;

            public clientinfo_t[] clientinfo;
            public clientinfo_t	baseclientinfo;
        }

        /* the client_static_t structure is persistant through
        an arbitrary number of server connections */
        private enum connstate_t
        {
            ca_uninitialized,
            ca_disconnected,  /* not talking to a server */
            ca_connecting, /* sending request packets to the server */
            ca_connected, /* netchan_t established, waiting for svc_serverdata */
            ca_active /* game views should be displayed */
        }

        private enum dltype_t
        {
            dl_none,
            dl_model,
            dl_sound,
            dl_skin,
            dl_single
        }

        private enum keydest_t {key_game, key_console, key_message, key_menu}

        private struct client_static_t
        {
            public connstate_t	state;
            public keydest_t	key_dest;

            public int			framecount;
            public int			realtime; /* always increasing, no clamping, etc, in MS */
            public float		rframetime; /* seconds since last render frame */
            public float		nframetime; /* network frame time */

            /* screen rendering information */
            public float		disable_screen; /* showing loading plaque between levels */
                                        /* or changing rendering dlls */

            /* if time gets > 30 seconds ahead, break it */
            public int			disable_servercount; /* when we receive a frame and cl.servercount */
                                            /* > cls.disable_servercount, clear disable_screen */

            /* connection information */
            public string		servername; /* name of server from original connect */
            public float		connect_time; /* for connection retransmits */

            public int			quakePort; /* a 16 bit value that allows quake servers */
                                /* to work around address translating routers */
            public QCommon.netchan_t	netchan;
            public int			serverProtocol; /* in case we are doing some kind of version hack */

            public int			challenge; /* from the server to use for connecting */

            public bool	forcePacket; /* Forces a package to be send at the next frame. */

        //     FILE		*download; /* file transfer from server */
        //     char		downloadtempname[MAX_OSPATH];
        //     char		downloadname[MAX_OSPATH];
        //     int			downloadnumber;
        //     dltype_t	downloadtype;
        //     size_t		downloadposition;
        //     int			downloadpercent;

        //     /* demo recording info must be here, so it isn't cleared on level change */
        //     qboolean	demorecording;
        //     qboolean	demowaiting; /* don't record until a non-delta message is received */
        //     FILE		*demofile;

        // #ifdef USE_CURL
        //     /* http downloading */
        //     dlqueue_t  downloadQueue; /* queues with files to download. */
        //     dlhandle_t HTTPHandles[MAX_HTTP_HANDLES]; /* download handles. */
        //     char	   downloadServer[512]; /* URL prefix to dowload from .*/
        //     char	   downloadServerRetry[512]; /* retry count. */
        //     char	   downloadReferer[32]; /* referer string. */
        // #endif
        }

        public bool attractloop {
            get { return cl.attractloop; }
        }

    }
}